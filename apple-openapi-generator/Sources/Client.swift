// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// API for finding and booking train trips across Europe.
///
/// ## Run in Postman
///
/// Experiment with this API in Postman, using our Postman Collection.
///
/// [![Run In Postman](https://run.pstmn.io/button.svg =128pxx32px)](https://app.getpostman.com/run-collection/9265903-7a75a0d0-b108-4436-ba54-c6139698dc08?action=collection%2Ffork&source=rip_markdown&collection-url=entityId%3D9265903-7a75a0d0-b108-4436-ba54-c6139698dc08%26entityType%3Dcollection%26workspaceId%3Df507f69d-9564-419c-89a2-cb8e4c8c7b8f)
///
internal struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get a list of train stations
    ///
    /// Returns a paginated and searchable list of all train stations.
    ///
    /// - Remark: HTTP `GET /stations`.
    /// - Remark: Generated from `#/paths//stations/get(get-stations)`.
    internal func getStations(_ input: Operations.GetStations.Input) async throws -> Operations.GetStations.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetStations.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/stations",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "coordinates",
                    value: input.query.coordinates
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "country",
                    value: input.query.country
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.GetStations.Output.Ok.Headers = .init(
                        cacheControl: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Cache-Control",
                            as: Components.Headers.CacheControl.self
                        ),
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetStations.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetStations.Output.Ok.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let headers: Components.Responses.BadRequest.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Components.Responses.Unauthorized.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Components.Responses.Forbidden.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Components.Responses.TooManyRequests.Headers = .init(
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        ),
                        retryAfter: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Retry-After",
                            as: Components.Headers.RetryAfter.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Components.Responses.InternalServerError.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get available train trips
    ///
    /// Returns a list of available train trips between the specified origin and destination stations on the given date, and allows for filtering by bicycle and dog allowances.
    ///
    ///
    /// - Remark: HTTP `GET /trips`.
    /// - Remark: Generated from `#/paths//trips/get(get-trips)`.
    internal func getTrips(_ input: Operations.GetTrips.Input) async throws -> Operations.GetTrips.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetTrips.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/trips",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "origin",
                    value: input.query.origin
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "destination",
                    value: input.query.destination
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "date",
                    value: input.query.date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "bicycles",
                    value: input.query.bicycles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "dogs",
                    value: input.query.dogs
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.GetTrips.Output.Ok.Headers = .init(
                        cacheControl: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Cache-Control",
                            as: Components.Headers.CacheControl.self
                        ),
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetTrips.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetTrips.Output.Ok.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let headers: Components.Responses.BadRequest.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Components.Responses.Unauthorized.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Components.Responses.Forbidden.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Components.Responses.TooManyRequests.Headers = .init(
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        ),
                        retryAfter: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Retry-After",
                            as: Components.Headers.RetryAfter.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Components.Responses.InternalServerError.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List existing bookings
    ///
    /// Returns a list of all trip bookings by the authenticated user.
    ///
    /// - Remark: HTTP `GET /bookings`.
    /// - Remark: Generated from `#/paths//bookings/get(get-bookings)`.
    internal func getBookings(_ input: Operations.GetBookings.Input) async throws -> Operations.GetBookings.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetBookings.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/bookings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.GetBookings.Output.Ok.Headers = .init(
                        cacheControl: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Cache-Control",
                            as: Components.Headers.CacheControl.self
                        ),
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetBookings.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetBookings.Output.Ok.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let headers: Components.Responses.BadRequest.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Components.Responses.Unauthorized.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Components.Responses.Forbidden.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Components.Responses.TooManyRequests.Headers = .init(
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        ),
                        retryAfter: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Retry-After",
                            as: Components.Headers.RetryAfter.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Components.Responses.InternalServerError.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a booking
    ///
    /// A booking is a temporary hold on a trip. It is not confirmed until the payment is processed.
    ///
    /// - Remark: HTTP `POST /bookings`.
    /// - Remark: Generated from `#/paths//bookings/post(create-booking)`.
    internal func createBooking(_ input: Operations.CreateBooking.Input) async throws -> Operations.CreateBooking.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CreateBooking.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/bookings",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .xml(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/xml"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CreateBooking.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CreateBooking.Output.Created.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let headers: Components.Responses.BadRequest.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Components.Responses.Unauthorized.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Components.Responses.NotFound.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 409:
                    let headers: Components.Responses.Conflict.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Components.Responses.TooManyRequests.Headers = .init(
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        ),
                        retryAfter: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Retry-After",
                            as: Components.Headers.RetryAfter.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Components.Responses.InternalServerError.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a booking
    ///
    /// Returns the details of a specific booking.
    ///
    /// - Remark: HTTP `GET /bookings/{bookingId}`.
    /// - Remark: Generated from `#/paths//bookings/{bookingId}/get(get-booking)`.
    internal func getBooking(_ input: Operations.GetBooking.Input) async throws -> Operations.GetBooking.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetBooking.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/bookings/{}",
                    parameters: [
                        input.path.bookingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.GetBooking.Output.Ok.Headers = .init(
                        cacheControl: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Cache-Control",
                            as: Components.Headers.CacheControl.self
                        ),
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetBooking.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetBooking.Output.Ok.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .xml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let headers: Components.Responses.BadRequest.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Components.Responses.Unauthorized.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Components.Responses.Forbidden.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Components.Responses.NotFound.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Components.Responses.TooManyRequests.Headers = .init(
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        ),
                        retryAfter: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Retry-After",
                            as: Components.Headers.RetryAfter.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Components.Responses.InternalServerError.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a booking
    ///
    /// Deletes a booking, cancelling the hold on the trip.
    ///
    /// - Remark: HTTP `DELETE /bookings/{bookingId}`.
    /// - Remark: Generated from `#/paths//bookings/{bookingId}/delete(delete-booking)`.
    internal func deleteBooking(_ input: Operations.DeleteBooking.Input) async throws -> Operations.DeleteBooking.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DeleteBooking.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/bookings/{}",
                    parameters: [
                        input.path.bookingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    let headers: Components.Responses.BadRequest.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Components.Responses.Unauthorized.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Components.Responses.Forbidden.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Components.Responses.NotFound.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Components.Responses.TooManyRequests.Headers = .init(
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        ),
                        retryAfter: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Retry-After",
                            as: Components.Headers.RetryAfter.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Components.Responses.InternalServerError.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Pay for a Booking
    ///
    /// A payment is an attempt to pay for the booking, which will confirm the booking for the user and enable them to get their tickets.
    ///
    /// - Remark: HTTP `POST /bookings/{bookingId}/payment`.
    /// - Remark: Generated from `#/paths//bookings/{bookingId}/payment/post(create-booking-payment)`.
    internal func createBookingPayment(_ input: Operations.CreateBookingPayment.Input) async throws -> Operations.CreateBookingPayment.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CreateBookingPayment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/bookings/{}/payment",
                    parameters: [
                        input.path.bookingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.CreateBookingPayment.Output.Ok.Headers = .init(
                        cacheControl: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Cache-Control",
                            as: Components.Headers.CacheControl.self
                        ),
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CreateBookingPayment.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CreateBookingPayment.Output.Ok.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 400:
                    let headers: Components.Responses.BadRequest.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Components.Responses.Unauthorized.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Components.Responses.Forbidden.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Components.Responses.TooManyRequests.Headers = .init(
                        rateLimit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "RateLimit",
                            as: Components.Headers.RateLimit.self
                        ),
                        retryAfter: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Retry-After",
                            as: Components.Headers.RetryAfter.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Components.Responses.InternalServerError.Headers = .init(rateLimit: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "RateLimit",
                        as: Components.Headers.RateLimit.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/problem+json",
                            "application/problem+xml"
                        ]
                    )
                    switch chosenContentType {
                    case "application/problem+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Problem.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemJson(value)
                            }
                        )
                    case "application/problem+xml":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .applicationProblemXml(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
